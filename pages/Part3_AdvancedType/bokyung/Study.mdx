# [3장] 고급 타입

## 3.1 타입스크립트만의 독자적 타입 시스템

-   타입스크립트는 자바스크립트 자료형에서 제시되지 않은 독자적인 타입 시스템을 가지고 있다.
-   any, unknown 등은 타입스크립트에만 존재하는 독자적인 타입 시스템이다.
    <img
        width='711'
        alt='스크린샷 2024-04-27 오후 9 51 56'
        src='https://github.com/HOJOON07/wooahan_TS-with-React/assets/108623656/54691ad9-7942-4a8e-ab6b-c6d05740a8c8'
    />

### any 타입

-   타입을 명시하지 않은 것과 동일한 효과를 나타낸다.
-   any 타입을 변수에 할당하는 것은 지양해야 할 패턴으로 알려져 있다.
-   any 타입을 어쩔 수 없이 사용해야 할 때
    -   개발 단계에서 임시로 값을 지정해야 할 때
    -   어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때
    -   값을 예측할 수 없을 때 암묵적으로 사용

### unknown 타입

-   unknown 타입은 any 타입과 유사하게 모든 타입의 값이 할당될 수 있다. 그러나 any를 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값을 할당할 수 없다.

```tsx
// 할당하는 시점에서는 에러가 발생하지 않음
const unknownFunction: unknown = () => console.log(this is unknown type);

// 하지만 실행 시에는 에러가 발생; Error: Object is of type unknown.ts (2571)
unknownFunction();
```

-   any를 보완하기 위한 타입

### void 타입

-   자바스크립트에서는 함수에서 명시적인 반환문을 작성하지 않으면 기본적으로 undefined가 반환된다. 하지만 타입스크립트에서는 void 타입이 사용되는데 이것은 undefined가 아니다. 타입스크립트에서 함수가 어떤 값을 반환하지 않는 경우에는 void를 지정하여 사용한다고 생각하면 된다.
-   함수 내부에 별도 반환문이 없다면 타입스크립트 컴파일러가 알아서 함수 타입을 void로 추론해주기 때문이다.

### never 타입

-   값을 반환할 수 없는 타입
-   void는 값을 반환하지 않는 타입이지만, never는 값을 반환할 수 없는 타입이다.
-   값을 반환할 수 없는 경우는 크게 2가지가 있다.
    -   에러를 던지는 경우 `throw new Error()`
    -   무한히 함수가 실행되는 경우 `while(true)`

### Array 타입

-   자바스크립트에서는 배열에 숫자, 문자열, 함수 등 다양한 값을 삽입할 수 있다.
    -   하지만 이런 개념은 타입스크립트의 정적 타이핑과 잘 부합하지 않는다.
    -   그러나 필요하다면 유니온 타입을 사용할 수 있다.
    ```tsx
    const array1: Array<number | string> = [1, 'string'];
    const array2: number[] | string[] = [1, 'string'];
    const array3: (number | string)[] = [1, 'string'];
    ```
-   튜플도 대괄호를 사용해서 선언할 수 있다.
-   튜플은 배열의 특정 인덱스에 정해진 타입을 선언한다.
-   튜플은 길이까지 제한하여 원소 개수와 타입을 보장한다.

```tsx
let tuple: [number] = [1];
tuple = [1, 2]; // 불가능
tuple = [1, 'string']; // 불가능

let tuple: [number, string, boolean] = [1, 'string', true]; // 여러 타입과 혼합도 가능하다
```

-   스프레드 연산자를 사용하여 나머지 인덱스를 정할 수도 있다.

```tsx
const httpStatusFromPaths: [number, string, ...string[]] = [
    400,
    'Bad Request',
    '/users/:id',
    '/users/:userId',
    '/users/:uuid'
];
```

-   또한 튜플에서도 물음표 기호와 함께 옵셔널로 사용할 수도 있다.

```tsx
const optionalTuple1: [number, number, number?] = [1, 2];
const optionalTuple2: [number, number, number?] = [1, 2, 3]; // 3번째 인덱스에 해당하는 숫자형 원소는 있어도 되고 없어도 됨을 의미한다
```

### enum 타입

-   `열거형` 이라고도 한다.
-   앞서 말했듯 타입 공간과 값 공간 모두에서 사용이 가능하다.

```tsx
enum ProgrammingLanguage {
    Typescript, // 0
    Javascript, // 1
    Java, // 2
    Python, // 3
    Kotlin, // 4
    Rust, // 5
    Go // 6
}

// 각 멤버에게 접근하는 방식은 자바스크립트에서 객체의 속성에 접근하는 방식과 동일하다
ProgrammingLanguage.Typescript; // 0
ProgrammingLanguage.Rust; // 5
ProgrammingLanguage['Go']; // 6

// 또한 역방향으로도 접근이 가능하다
ProgrammingLanguage[2]; // Java
```

-   모든 멤버에 일일이 값을 할당할 수도 있지만, 일부 멤버에 값을 직접 할당하지 않아도 타입스크립트는 누락된 멤버를 아래와 같은 방식으로 이전 멤버 값의 숫자를 기준으로 1씩 늘려가며 자동으로 할당한다.

```tsx
enum ProgrammingLanguage {
    Typescript = 'TypeScript',
    Javascript = 'JavaScript',
    Java = 300,
    Python = 400,
    Kotlin, // 401
    Rust, // 402
    Go // 403
}
```

-   const enum으로 선언하면 역방향으로 접근이 불가능하다.

```tsx
ProgrammingLanguage[200]; // 역방향 접근이 가능하여 undefined를 출력하지만 별다른 에러를 발생시키지 않는다

// 다음과 같이 선언하면 위와 같은 문제를 방지할 수 있다
const enum ProgrammingLanguage {}
```

-   또한 열거형은 타입스크립트 코드가 자바스크립트로 변환될 때 즉시 실행 함수(IIFE)형식으로 변환되는 것을 볼 수 있다.
    -   이때 일부 번들러에서 트리쉐이킹 과정 중 즉시 실행 함수로 변환된 값을 사용하지 않는 코드로 인식하지 못하는 경우가 발생할 수 있다. 따라서 불필요한 코드의 크기가 증가하는 결과를 초래할 수 있다.
    -   이러한 문제를 해결하기 위해 `const enum` 또는 `as const assertion`을 사용할 수 있다.

## 3.2 타입 조합
